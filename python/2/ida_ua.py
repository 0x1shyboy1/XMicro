# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.0
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""
IDA Plugin SDK API wrapper: ua
"""

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError('Python 2.7 or later required')

# Import the low-level C/C++ module
if __package__ or '.' in __name__:
    from . import _ida_ua
else:
    import _ida_ua

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if name == "thisown":
        return self.this.own(value)
    if name == "this":
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if not static:
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if name == "thisown":
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """
    Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass
    """
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """
    Meta class to enforce nondynamic attributes (no new attributes) for a class
    """
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SWIG_PYTHON_LEGACY_BOOL = _ida_ua.SWIG_PYTHON_LEGACY_BOOL

import ida_idaapi


import sys
_BC695 = sys.modules["__main__"].IDAPYTHON_COMPAT_695_API

if _BC695:






    def bc695redef(func):
        ida_idaapi._BC695.replace_fun(func)
        return func

class operands_array(object):
    r"""
    Proxy of C++ wrapped_array_t< op_t,8 > class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    data = property(_ida_ua.operands_array_data_get)

    def __init__(self, *args):
        r"""
        __init__(self, data) -> operands_array
        """
        _ida_ua.operands_array_swiginit(self, _ida_ua.new_operands_array(*args))

    def __len__(self, *args):
        r"""
        __len__(self) -> size_t
        """
        return _ida_ua.operands_array___len__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, i) -> op_t
        """
        return _ida_ua.operands_array___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, i, v)
        """
        return _ida_ua.operands_array___setitem__(self, *args)

    __iter__ = ida_idaapi._bounded_getitem_iterator

    __swig_destroy__ = _ida_ua.delete_operands_array

# Register operands_array in _ida_ua:
_ida_ua.operands_array_swigregister(operands_array)

class op_t(object):
    r"""
    Proxy of C++ op_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    n = property(_ida_ua.op_t_n_get, _ida_ua.op_t_n_set)
    type = property(_ida_ua.op_t_type_get, _ida_ua.op_t_type_set)
    offb = property(_ida_ua.op_t_offb_get, _ida_ua.op_t_offb_set)
    offo = property(_ida_ua.op_t_offo_get, _ida_ua.op_t_offo_set)
    flags = property(_ida_ua.op_t_flags_get, _ida_ua.op_t_flags_set)

    def set_shown(self, *args):
        r"""
        set_shown(self)
        """
        return _ida_ua.op_t_set_shown(self, *args)

    def clr_shown(self, *args):
        r"""
        clr_shown(self)
        """
        return _ida_ua.op_t_clr_shown(self, *args)

    def shown(self, *args):
        r"""
        shown(self) -> bool
        """
        return _ida_ua.op_t_shown(self, *args)
    dtype = property(_ida_ua.op_t_dtype_get, _ida_ua.op_t_dtype_set)

    def is_reg(self, *args):
        r"""
        is_reg(self, r) -> bool
        """
        return _ida_ua.op_t_is_reg(self, *args)

    def is_imm(self, *args):
        r"""
        is_imm(self, v) -> bool
        """
        return _ida_ua.op_t_is_imm(self, *args)
    specflag1 = property(_ida_ua.op_t_specflag1_get, _ida_ua.op_t_specflag1_set)
    specflag2 = property(_ida_ua.op_t_specflag2_get, _ida_ua.op_t_specflag2_set)
    specflag3 = property(_ida_ua.op_t_specflag3_get, _ida_ua.op_t_specflag3_set)
    specflag4 = property(_ida_ua.op_t_specflag4_get, _ida_ua.op_t_specflag4_set)

    def __get_reg_phrase__(self, *args):
        r"""
        __get_reg_phrase__(self) -> uint16
        """
        return _ida_ua.op_t___get_reg_phrase__(self, *args)

    def __set_reg_phrase__(self, *args):
        r"""
        __set_reg_phrase__(self, r)
        """
        return _ida_ua.op_t___set_reg_phrase__(self, *args)

    def __get_value__(self, *args):
        r"""
        __get_value__(self) -> ea_t
        """
        return _ida_ua.op_t___get_value__(self, *args)

    def __set_value__(self, *args):
        r"""
        __set_value__(self, v)
        """
        return _ida_ua.op_t___set_value__(self, *args)

    def __get_addr__(self, *args):
        r"""
        __get_addr__(self) -> ea_t
        """
        return _ida_ua.op_t___get_addr__(self, *args)

    def __set_addr__(self, *args):
        r"""
        __set_addr__(self, v)
        """
        return _ida_ua.op_t___set_addr__(self, *args)

    def __get_specval__(self, *args):
        r"""
        __get_specval__(self) -> ea_t
        """
        return _ida_ua.op_t___get_specval__(self, *args)

    def __set_specval__(self, *args):
        r"""
        __set_specval__(self, v)
        """
        return _ida_ua.op_t___set_specval__(self, *args)

    def assign(self, *args):
        r"""
        assign(self, other)
        """
        return _ida_ua.op_t_assign(self, *args)

    def has_reg(self, r):
        """
        Checks if the operand accesses the given processor register
        """
        return self.reg == r.reg

    reg = property(__get_reg_phrase__, __set_reg_phrase__)
    phrase = property(__get_reg_phrase__, __set_reg_phrase__)
    value = property(__get_value__, __set_value__)
    addr = property(__get_addr__, __set_addr__)
    specval = property(__get_specval__, __set_specval__)


    def __init__(self, *args):
        r"""
        __init__(self) -> op_t
        """
        _ida_ua.op_t_swiginit(self, _ida_ua.new_op_t(*args))
    __swig_destroy__ = _ida_ua.delete_op_t

# Register op_t in _ida_ua:
_ida_ua.op_t_swigregister(op_t)
cvar = _ida_ua.cvar
o_void = cvar.o_void
o_reg = cvar.o_reg
o_mem = cvar.o_mem
o_phrase = cvar.o_phrase
o_displ = cvar.o_displ
o_imm = cvar.o_imm
o_far = cvar.o_far
o_near = cvar.o_near
o_idpspec0 = cvar.o_idpspec0
o_idpspec1 = cvar.o_idpspec1
o_idpspec2 = cvar.o_idpspec2
o_idpspec3 = cvar.o_idpspec3
o_idpspec4 = cvar.o_idpspec4
o_idpspec5 = cvar.o_idpspec5
OF_NO_BASE_DISP = _ida_ua.OF_NO_BASE_DISP
"""
base displacement doesn't exist. meaningful only for 'o_displ' type.
if set, base displacement ( 'op_t::addr' ) doesn't exist.
"""

OF_OUTER_DISP = _ida_ua.OF_OUTER_DISP
"""
outer displacement exists. meaningful only for 'o_displ' type. if set,
outer displacement ( 'op_t::value' ) exists.
"""

PACK_FORM_DEF = _ida_ua.PACK_FORM_DEF
"""
(! 'o_reg' + 'dt_packreal' )

packed factor defined.
"""

OF_NUMBER = _ida_ua.OF_NUMBER
"""
the operand can be converted to a number only
"""

OF_SHOW = _ida_ua.OF_SHOW
"""
should the operand be displayed?
"""

dt_byte = _ida_ua.dt_byte
"""
8 bit integer
"""

dt_word = _ida_ua.dt_word
"""
16 bit integer
"""

dt_dword = _ida_ua.dt_dword
"""
32 bit integer
"""

dt_float = _ida_ua.dt_float
"""
4 byte floating point
"""

dt_double = _ida_ua.dt_double
"""
8 byte floating point
"""

dt_tbyte = _ida_ua.dt_tbyte
"""
variable size (\\ph{tbyte_size}) floating point
"""

dt_packreal = _ida_ua.dt_packreal
"""
packed real format for mc68040
"""

dt_qword = _ida_ua.dt_qword
"""
64 bit integer
"""

dt_byte16 = _ida_ua.dt_byte16
"""
128 bit integer
"""

dt_code = _ida_ua.dt_code
"""
ptr to code (not used?)
"""

dt_void = _ida_ua.dt_void
"""
none
"""

dt_fword = _ida_ua.dt_fword
"""
48 bit
"""

dt_bitfild = _ida_ua.dt_bitfild
"""
bit field (mc680x0)
"""

dt_string = _ida_ua.dt_string
"""
pointer to asciiz string
"""

dt_unicode = _ida_ua.dt_unicode
"""
pointer to unicode string
"""

dt_ldbl = _ida_ua.dt_ldbl
"""
long double (which may be different from tbyte)
"""

dt_byte32 = _ida_ua.dt_byte32
"""
256 bit integer
"""

dt_byte64 = _ida_ua.dt_byte64
"""
512 bit integer
"""

dt_half = _ida_ua.dt_half
"""
2-byte floating point
"""



def insn_add_cref(*args):
    r"""
    insn_add_cref(insn, to, opoff, type)
    """
    return _ida_ua.insn_add_cref(*args)

def insn_add_dref(*args):
    r"""
    insn_add_dref(insn, to, opoff, type)
    """
    return _ida_ua.insn_add_dref(*args)

def insn_add_off_drefs(*args):
    r"""
    insn_add_off_drefs(insn, x, type, outf) -> ea_t
    """
    return _ida_ua.insn_add_off_drefs(*args)

def insn_create_stkvar(*args):
    r"""
    insn_create_stkvar(insn, x, v, flags) -> bool
    """
    return _ida_ua.insn_create_stkvar(*args)
class insn_t(object):
    r"""
    Proxy of C++ insn_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> insn_t
        """
        _ida_ua.insn_t_swiginit(self, _ida_ua.new_insn_t(*args))
    cs = property(_ida_ua.insn_t_cs_get, _ida_ua.insn_t_cs_set)
    ip = property(_ida_ua.insn_t_ip_get, _ida_ua.insn_t_ip_set)
    ea = property(_ida_ua.insn_t_ea_get, _ida_ua.insn_t_ea_set)
    itype = property(_ida_ua.insn_t_itype_get, _ida_ua.insn_t_itype_set)

    def is_canon_insn(self, *args):
        r"""
        is_canon_insn(self) -> bool
        """
        return _ida_ua.insn_t_is_canon_insn(self, *args)

    def get_canon_feature(self, *args):
        r"""
        get_canon_feature(self) -> uint32
        """
        return _ida_ua.insn_t_get_canon_feature(self, *args)

    def get_canon_mnem(self, *args):
        r"""
        get_canon_mnem(self) -> char const *
        """
        return _ida_ua.insn_t_get_canon_mnem(self, *args)
    size = property(_ida_ua.insn_t_size_get, _ida_ua.insn_t_size_set)
    segpref = property(_ida_ua.insn_t_segpref_get, _ida_ua.insn_t_segpref_set)
    insnpref = property(_ida_ua.insn_t_insnpref_get, _ida_ua.insn_t_insnpref_set)
    flags = property(_ida_ua.insn_t_flags_get, _ida_ua.insn_t_flags_set)
    ops = property(_ida_ua.insn_t_ops_get, _ida_ua.insn_t_ops_set)

    def is_macro(self, *args):
        r"""
        is_macro(self) -> bool
        """
        return _ida_ua.insn_t_is_macro(self, *args)

    def is_64bit(self, *args):
        r"""
        is_64bit(self) -> bool
        """
        return _ida_ua.insn_t_is_64bit(self, *args)

    def get_next_byte(self, *args):
        r"""
        get_next_byte(self) -> uint8
        """
        return _ida_ua.insn_t_get_next_byte(self, *args)

    def get_next_word(self, *args):
        r"""
        get_next_word(self) -> uint16
        """
        return _ida_ua.insn_t_get_next_word(self, *args)

    def get_next_dword(self, *args):
        r"""
        get_next_dword(self) -> uint32
        """
        return _ida_ua.insn_t_get_next_dword(self, *args)

    def get_next_qword(self, *args):
        r"""
        get_next_qword(self) -> uint64
        """
        return _ida_ua.insn_t_get_next_qword(self, *args)

    def create_op_data(self, *args):
        r"""
        create_op_data(self, ea_, opoff, dtype) -> bool
        create_op_data(self, ea_, op) -> bool
        """
        return _ida_ua.insn_t_create_op_data(self, *args)

    def create_stkvar(self, *args):
        r"""
        create_stkvar(self, x, v, flags_) -> bool
        """
        return _ida_ua.insn_t_create_stkvar(self, *args)

    def add_cref(self, *args):
        r"""
        add_cref(self, to, opoff, type)
        """
        return _ida_ua.insn_t_add_cref(self, *args)

    def add_dref(self, *args):
        r"""
        add_dref(self, to, opoff, type)
        """
        return _ida_ua.insn_t_add_dref(self, *args)

    def add_off_drefs(self, *args):
        r"""
        add_off_drefs(self, x, type, outf) -> ea_t
        """
        return _ida_ua.insn_t_add_off_drefs(self, *args)

    def __get_ops__(self, *args):
        r"""
        __get_ops__(self) -> operands_array
        """
        return _ida_ua.insn_t___get_ops__(self, *args)

    def __get_operand__(self, *args):
        r"""
        __get_operand__(self, n) -> op_t
        """
        return _ida_ua.insn_t___get_operand__(self, *args)

    def __get_auxpref__(self, *args):
        r"""
        __get_auxpref__(self) -> uint16
        """
        return _ida_ua.insn_t___get_auxpref__(self, *args)

    def __set_auxpref__(self, *args):
        r"""
        __set_auxpref__(self, v)
        """
        return _ida_ua.insn_t___set_auxpref__(self, *args)

    def assign(self, *args):
        r"""
        assign(self, other)
        """
        return _ida_ua.insn_t_assign(self, *args)

    ops = property(__get_ops__)

    if _BC695:
        Operands = ops

    Op1 = property(lambda self: self.__get_operand__(0))
    Op2 = property(lambda self: self.__get_operand__(1))
    Op3 = property(lambda self: self.__get_operand__(2))
    Op4 = property(lambda self: self.__get_operand__(3))
    Op5 = property(lambda self: self.__get_operand__(4))
    Op6 = property(lambda self: self.__get_operand__(5))

    auxpref = property(__get_auxpref__, __set_auxpref__)

    def __iter__(self):
        return (self.ops[idx] for idx in range(0, 8))

    def __getitem__(self, idx):
        """
        Operands can be accessed directly as indexes
        @return op_t: Returns an operand of type op_t
        """
        if idx >= 8:
            raise KeyError
        else:
            return self.ops[idx]

    __swig_destroy__ = _ida_ua.delete_insn_t

# Register insn_t in _ida_ua:
_ida_ua.insn_t_swigregister(insn_t)
INSN_MACRO = _ida_ua.INSN_MACRO
"""
macro instruction
"""

INSN_MODMAC = _ida_ua.INSN_MODMAC
"""
may modify the database to make room for the macro insn
"""

INSN_64BIT = _ida_ua.INSN_64BIT
"""
belongs to 64bit segment?
"""

STKVAR_VALID_SIZE = _ida_ua.STKVAR_VALID_SIZE



def get_lookback(*args):
    r"""
    get_lookback() -> int


    Number of instructions to look back. This variable is not used by the
    kernel. Its value may be specified in ida.cfg: LOOKBACK = <number>.
    IDP may use it as you like it. (TMS module uses it)
    """
    return _ida_ua.get_lookback(*args)

def calc_dataseg(*args):
    r"""
    calc_dataseg(insn, n=-1, rgnum=-1) -> ea_t


    Get data segment for the instruction operand. 'opnum' and 'rgnum' are
    meaningful only if the processor has segment registers.
    
    @param insn (C++: const  insn_t  &)
    @param n (C++: int)
    @param rgnum (C++: int)
    """
    return _ida_ua.calc_dataseg(*args)

def map_data_ea(*args):
    r"""
    map_data_ea(insn, addr, opnum=-1) -> ea_t
    map_data_ea(insn, op) -> ea_t


    Map a data address.
    
    @param insn: the current instruction (C++: const  insn_t  &)
    @param addr: the referenced address to map (C++: ea_t)
    @param opnum: operand number (C++: int)
    """
    return _ida_ua.map_data_ea(*args)

def map_code_ea(*args):
    r"""
    map_code_ea(insn, addr, opnum) -> ea_t
    map_code_ea(insn, op) -> ea_t


    Map a code address. This function takes into account the segment
    translations.
    
    @param insn: the current instruction (C++: const  insn_t  &)
    @param addr: the referenced address to map (C++: ea_t)
    @param opnum: operand number (C++: int)
    """
    return _ida_ua.map_code_ea(*args)

def map_ea(*args):
    r"""
    map_ea(insn, op, iscode) -> ea_t
    map_ea(insn, addr, opnum, iscode) -> ea_t
    """
    return _ida_ua.map_ea(*args)
class outctx_base_t(object):
    r"""
    Proxy of C++ outctx_base_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    insn_ea = property(_ida_ua.outctx_base_t_insn_ea_get, _ida_ua.outctx_base_t_insn_ea_set)
    outbuf = property(_ida_ua.outctx_base_t_outbuf_get, _ida_ua.outctx_base_t_outbuf_set)
    default_lnnum = property(_ida_ua.outctx_base_t_default_lnnum_get, _ida_ua.outctx_base_t_default_lnnum_set)

    def only_main_line(self, *args):
        r"""
        only_main_line(self) -> bool
        """
        return _ida_ua.outctx_base_t_only_main_line(self, *args)

    def multiline(self, *args):
        r"""
        multiline(self) -> bool
        """
        return _ida_ua.outctx_base_t_multiline(self, *args)

    def force_code(self, *args):
        r"""
        force_code(self) -> bool
        """
        return _ida_ua.outctx_base_t_force_code(self, *args)

    def stack_view(self, *args):
        r"""
        stack_view(self) -> bool
        """
        return _ida_ua.outctx_base_t_stack_view(self, *args)

    def display_voids(self, *args):
        r"""
        display_voids(self) -> bool
        """
        return _ida_ua.outctx_base_t_display_voids(self, *args)

    def set_gen_xrefs(self, *args):
        r"""
        set_gen_xrefs(self, on=True)
        """
        return _ida_ua.outctx_base_t_set_gen_xrefs(self, *args)

    def set_gen_cmt(self, *args):
        r"""
        set_gen_cmt(self, on=True)
        """
        return _ida_ua.outctx_base_t_set_gen_cmt(self, *args)

    def clr_gen_label(self, *args):
        r"""
        clr_gen_label(self)
        """
        return _ida_ua.outctx_base_t_clr_gen_label(self, *args)

    def set_gen_label(self, *args):
        r"""
        set_gen_label(self)
        """
        return _ida_ua.outctx_base_t_set_gen_label(self, *args)

    def set_gen_demangled_label(self, *args):
        r"""
        set_gen_demangled_label(self)
        """
        return _ida_ua.outctx_base_t_set_gen_demangled_label(self, *args)

    def set_comment_addr(self, *args):
        r"""
        set_comment_addr(self, ea)
        """
        return _ida_ua.outctx_base_t_set_comment_addr(self, *args)

    def set_dlbind_opnd(self, *args):
        r"""
        set_dlbind_opnd(self)
        """
        return _ida_ua.outctx_base_t_set_dlbind_opnd(self, *args)

    def print_label_now(self, *args):
        r"""
        print_label_now(self) -> bool
        """
        return _ida_ua.outctx_base_t_print_label_now(self, *args)

    def forbid_annotations(self, *args):
        r"""
        forbid_annotations(self) -> int
        """
        return _ida_ua.outctx_base_t_forbid_annotations(self, *args)

    def restore_ctxflags(self, *args):
        r"""
        restore_ctxflags(self, saved_flags)
        """
        return _ida_ua.outctx_base_t_restore_ctxflags(self, *args)

    def out_printf(self, *args):
        r"""
        out_printf(self, format)
        """
        return _ida_ua.outctx_base_t_out_printf(self, *args)

    def out_value(self, *args):
        r"""
        out_value(self, x, outf=0) -> flags_t
        """
        return _ida_ua.outctx_base_t_out_value(self, *args)

    def out_symbol(self, *args):
        r"""
        out_symbol(self, c)
        """
        return _ida_ua.outctx_base_t_out_symbol(self, *args)

    def out_chars(self, *args):
        r"""
        out_chars(self, c, n)
        """
        return _ida_ua.outctx_base_t_out_chars(self, *args)

    def out_spaces(self, *args):
        r"""
        out_spaces(self, len)
        """
        return _ida_ua.outctx_base_t_out_spaces(self, *args)

    def out_line(self, *args):
        r"""
        out_line(self, str, color=0)
        """
        return _ida_ua.outctx_base_t_out_line(self, *args)

    def out_keyword(self, *args):
        r"""
        out_keyword(self, str)
        """
        return _ida_ua.outctx_base_t_out_keyword(self, *args)

    def out_register(self, *args):
        r"""
        out_register(self, str)
        """
        return _ida_ua.outctx_base_t_out_register(self, *args)

    def out_tagon(self, *args):
        r"""
        out_tagon(self, tag)
        """
        return _ida_ua.outctx_base_t_out_tagon(self, *args)

    def out_tagoff(self, *args):
        r"""
        out_tagoff(self, tag)
        """
        return _ida_ua.outctx_base_t_out_tagoff(self, *args)

    def out_addr_tag(self, *args):
        r"""
        out_addr_tag(self, ea)
        """
        return _ida_ua.outctx_base_t_out_addr_tag(self, *args)

    def out_colored_register_line(self, *args):
        r"""
        out_colored_register_line(self, str)
        """
        return _ida_ua.outctx_base_t_out_colored_register_line(self, *args)

    def out_char(self, *args):
        r"""
        out_char(self, c)
        """
        return _ida_ua.outctx_base_t_out_char(self, *args)

    def out_btoa(self, *args):
        r"""
        out_btoa(self, Word, radix=0)
        """
        return _ida_ua.outctx_base_t_out_btoa(self, *args)

    def out_long(self, *args):
        r"""
        out_long(self, v, radix)
        """
        return _ida_ua.outctx_base_t_out_long(self, *args)

    def out_name_expr(self, *args):
        r"""
        out_name_expr(self, x, ea, off=BADADDR) -> bool
        """
        return _ida_ua.outctx_base_t_out_name_expr(self, *args)

    def close_comment(self, *args):
        r"""
        close_comment(self)
        """
        return _ida_ua.outctx_base_t_close_comment(self, *args)

    def flush_outbuf(self, *args):
        r"""
        flush_outbuf(self, indent=-1) -> bool
        """
        return _ida_ua.outctx_base_t_flush_outbuf(self, *args)

    def flush_buf(self, *args):
        r"""
        flush_buf(self, buf, indent=-1) -> bool
        """
        return _ida_ua.outctx_base_t_flush_buf(self, *args)

    def term_outctx(self, *args):
        r"""
        term_outctx(self, prefix=None) -> int
        """
        return _ida_ua.outctx_base_t_term_outctx(self, *args)

    def gen_printf(self, *args):
        r"""
        gen_printf(self, indent, format) -> bool
        """
        return _ida_ua.outctx_base_t_gen_printf(self, *args)

    def gen_empty_line(self, *args):
        r"""
        gen_empty_line(self) -> bool
        """
        return _ida_ua.outctx_base_t_gen_empty_line(self, *args)

    def gen_border_line(self, *args):
        r"""
        gen_border_line(self, solid=False) -> bool
        """
        return _ida_ua.outctx_base_t_gen_border_line(self, *args)

    def gen_cmt_line(self, *args):
        r"""
        gen_cmt_line(self, format) -> bool
        """
        return _ida_ua.outctx_base_t_gen_cmt_line(self, *args)

    def gen_collapsed_line(self, *args):
        r"""
        gen_collapsed_line(self, format) -> bool
        """
        return _ida_ua.outctx_base_t_gen_collapsed_line(self, *args)

    def gen_block_cmt(self, *args):
        r"""
        gen_block_cmt(self, cmt, color) -> bool
        """
        return _ida_ua.outctx_base_t_gen_block_cmt(self, *args)

    def setup_outctx(self, *args):
        r"""
        setup_outctx(self, prefix, makeline_flags)
        """
        return _ida_ua.outctx_base_t_setup_outctx(self, *args)

    def retrieve_cmt(self, *args):
        r"""
        retrieve_cmt(self) -> ssize_t
        """
        return _ida_ua.outctx_base_t_retrieve_cmt(self, *args)

    def retrieve_name(self, *args):
        r"""
        retrieve_name(self, arg2, arg3) -> ssize_t
        """
        return _ida_ua.outctx_base_t_retrieve_name(self, *args)

    def gen_xref_lines(self, *args):
        r"""
        gen_xref_lines(self) -> bool
        """
        return _ida_ua.outctx_base_t_gen_xref_lines(self, *args)

    def init_lines_array(self, *args):
        r"""
        init_lines_array(self, answers, maxsize)
        """
        return _ida_ua.outctx_base_t_init_lines_array(self, *args)

    def get_stkvar(self, *args):
        r"""
        get_stkvar(self, arg2, arg3, arg4, arg5) -> member_t *
        """
        return _ida_ua.outctx_base_t_get_stkvar(self, *args)

    def gen_empty_line_without_annotations(self, *args):
        r"""
        gen_empty_line_without_annotations(self)
        """
        return _ida_ua.outctx_base_t_gen_empty_line_without_annotations(self, *args)

# Register outctx_base_t in _ida_ua:
_ida_ua.outctx_base_t_swigregister(outctx_base_t)
CTXF_MAIN = _ida_ua.CTXF_MAIN

CTXF_MULTI = _ida_ua.CTXF_MULTI

CTXF_CODE = _ida_ua.CTXF_CODE

CTXF_STACK = _ida_ua.CTXF_STACK

CTXF_GEN_XREFS = _ida_ua.CTXF_GEN_XREFS

CTXF_XREF_STATE = _ida_ua.CTXF_XREF_STATE

XREFSTATE_NONE = _ida_ua.XREFSTATE_NONE

XREFSTATE_GO = _ida_ua.XREFSTATE_GO

XREFSTATE_DONE = _ida_ua.XREFSTATE_DONE

CTXF_GEN_CMT = _ida_ua.CTXF_GEN_CMT

CTXF_CMT_STATE = _ida_ua.CTXF_CMT_STATE

COMMSTATE_NONE = _ida_ua.COMMSTATE_NONE

COMMSTATE_GO = _ida_ua.COMMSTATE_GO

COMMSTATE_DONE = _ida_ua.COMMSTATE_DONE

CTXF_VOIDS = _ida_ua.CTXF_VOIDS

CTXF_NORMAL_LABEL = _ida_ua.CTXF_NORMAL_LABEL

CTXF_DEMANGLED_LABEL = _ida_ua.CTXF_DEMANGLED_LABEL

CTXF_LABEL_OK = _ida_ua.CTXF_LABEL_OK

CTXF_DEMANGLED_OK = _ida_ua.CTXF_DEMANGLED_OK

CTXF_OVSTORE_PRNT = _ida_ua.CTXF_OVSTORE_PRNT

CTXF_OUTCTX_T = _ida_ua.CTXF_OUTCTX_T

CTXF_DBLIND_OPND = _ida_ua.CTXF_DBLIND_OPND

CTXF_BINOP_STATE = _ida_ua.CTXF_BINOP_STATE

BINOPSTATE_NONE = _ida_ua.BINOPSTATE_NONE

BINOPSTATE_GO = _ida_ua.BINOPSTATE_GO

BINOPSTATE_DONE = _ida_ua.BINOPSTATE_DONE

OOF_SIGNMASK = _ida_ua.OOF_SIGNMASK
"""
sign symbol (+/-) output
"""

OOFS_IFSIGN = _ida_ua.OOFS_IFSIGN
"""
output sign if needed
"""

OOFS_NOSIGN = _ida_ua.OOFS_NOSIGN
"""
don't output sign, forbid the user to change the sign
"""

OOFS_NEEDSIGN = _ida_ua.OOFS_NEEDSIGN
"""
always out sign (+-)
"""

OOF_SIGNED = _ida_ua.OOF_SIGNED
"""
output as signed if < 0
"""

OOF_NUMBER = _ida_ua.OOF_NUMBER
"""
always as a number
"""

OOF_WIDTHMASK = _ida_ua.OOF_WIDTHMASK
"""
width of value in bits
"""

OOFW_IMM = _ida_ua.OOFW_IMM
"""
take from x.dtype
"""

OOFW_8 = _ida_ua.OOFW_8
"""
8 bit width
"""

OOFW_16 = _ida_ua.OOFW_16
"""
16 bit width
"""

OOFW_24 = _ida_ua.OOFW_24
"""
24 bit width
"""

OOFW_32 = _ida_ua.OOFW_32
"""
32 bit width
"""

OOFW_64 = _ida_ua.OOFW_64
"""
64 bit width
"""

OOF_ADDR = _ida_ua.OOF_ADDR
"""
output x.addr, otherwise x.value
"""

OOF_OUTER = _ida_ua.OOF_OUTER
"""
output outer operand
"""

OOF_ZSTROFF = _ida_ua.OOF_ZSTROFF
"""
meaningful only if is_stroff(uFlag) append a struct field name if the
field offset is zero? if 'AFL_ZSTROFF' is set, then this flag is
ignored.
"""

OOF_NOBNOT = _ida_ua.OOF_NOBNOT
"""
prohibit use of binary not
"""

OOF_SPACES = _ida_ua.OOF_SPACES
"""
currently works only for floating point numbers

do not suppress leading spaces
"""

OOF_ANYSERIAL = _ida_ua.OOF_ANYSERIAL
"""
if enum: select first available serial
"""

DEFAULT_INDENT = _ida_ua.DEFAULT_INDENT

MAKELINE_NONE = _ida_ua.MAKELINE_NONE

MAKELINE_BINPREF = _ida_ua.MAKELINE_BINPREF

MAKELINE_VOID = _ida_ua.MAKELINE_VOID

MAKELINE_STACK = _ida_ua.MAKELINE_STACK


class outctx_t(outctx_base_t):
    r"""
    Proxy of C++ outctx_t class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    bin_ea = property(_ida_ua.outctx_t_bin_ea_get, _ida_ua.outctx_t_bin_ea_set)
    bin_state = property(_ida_ua.outctx_t_bin_state_get, _ida_ua.outctx_t_bin_state_set)
    gl_bpsize = property(_ida_ua.outctx_t_gl_bpsize_get, _ida_ua.outctx_t_gl_bpsize_set)
    bin_width = property(_ida_ua.outctx_t_bin_width_get, _ida_ua.outctx_t_bin_width_set)
    insn = property(_ida_ua.outctx_t_insn_get, _ida_ua.outctx_t_insn_set)
    curlabel = property(_ida_ua.outctx_t_curlabel_get, _ida_ua.outctx_t_curlabel_set)
    wif = property(_ida_ua.outctx_t_wif_get, _ida_ua.outctx_t_wif_set)

    def setup_outctx(self, *args):
        r"""
        setup_outctx(self, prefix, flags)
        """
        return _ida_ua.outctx_t_setup_outctx(self, *args)

    def retrieve_cmt(self, *args):
        r"""
        retrieve_cmt(self) -> ssize_t
        """
        return _ida_ua.outctx_t_retrieve_cmt(self, *args)

    def retrieve_name(self, *args):
        r"""
        retrieve_name(self, arg2, arg3) -> ssize_t
        """
        return _ida_ua.outctx_t_retrieve_name(self, *args)

    def gen_xref_lines(self, *args):
        r"""
        gen_xref_lines(self) -> bool
        """
        return _ida_ua.outctx_t_gen_xref_lines(self, *args)

    def set_bin_state(self, *args):
        r"""
        set_bin_state(self, value)
        """
        return _ida_ua.outctx_t_set_bin_state(self, *args)

    def out_mnem(self, *args):
        r"""
        out_mnem(self, width=8, postfix=None)
        """
        return _ida_ua.outctx_t_out_mnem(self, *args)

    def out_custom_mnem(self, *args):
        r"""
        out_custom_mnem(self, mnem, width=8, postfix=None)
        """
        return _ida_ua.outctx_t_out_custom_mnem(self, *args)

    def out_mnemonic(self, *args):
        r"""
        out_mnemonic(self)
        """
        return _ida_ua.outctx_t_out_mnemonic(self, *args)

    def out_one_operand(self, *args):
        r"""
        out_one_operand(self, n) -> bool
        """
        return _ida_ua.outctx_t_out_one_operand(self, *args)

    def out_immchar_cmts(self, *args):
        r"""
        out_immchar_cmts(self)
        """
        return _ida_ua.outctx_t_out_immchar_cmts(self, *args)

    def gen_func_header(self, *args):
        r"""
        gen_func_header(self, pfn)
        """
        return _ida_ua.outctx_t_gen_func_header(self, *args)

    def gen_func_footer(self, *args):
        r"""
        gen_func_footer(self, pfn)
        """
        return _ida_ua.outctx_t_gen_func_footer(self, *args)

    def out_data(self, *args):
        r"""
        out_data(self, analyze_only)
        """
        return _ida_ua.outctx_t_out_data(self, *args)

    def out_specea(self, *args):
        r"""
        out_specea(self, segtype) -> bool
        """
        return _ida_ua.outctx_t_out_specea(self, *args)

    def gen_header_extra(self, *args):
        r"""
        gen_header_extra(self)
        """
        return _ida_ua.outctx_t_gen_header_extra(self, *args)

    def gen_header(self, *args):
        r"""
        gen_header(self, flags=((1 << 0)|(1 << 1)), proc_name=None, proc_flavour=None)
        """
        return _ida_ua.outctx_t_gen_header(self, *args)

# Register outctx_t in _ida_ua:
_ida_ua.outctx_t_swigregister(outctx_t)
GH_PRINT_PROC = _ida_ua.GH_PRINT_PROC

GH_PRINT_ASM = _ida_ua.GH_PRINT_ASM

GH_PRINT_BYTESEX = _ida_ua.GH_PRINT_BYTESEX

GH_PRINT_HEADER = _ida_ua.GH_PRINT_HEADER

GH_BYTESEX_HAS_HIGHBYTE = _ida_ua.GH_BYTESEX_HAS_HIGHBYTE

GH_PRINT_PROC_AND_ASM = _ida_ua.GH_PRINT_PROC_AND_ASM

GH_PRINT_PROC_ASM_AND_BYTESEX = _ida_ua.GH_PRINT_PROC_ASM_AND_BYTESEX

GH_PRINT_ALL = _ida_ua.GH_PRINT_ALL

GH_PRINT_ALL_BUT_BYTESEX = _ida_ua.GH_PRINT_ALL_BUT_BYTESEX



def create_outctx(*args):
    r"""
    create_outctx(ea, F=0, suspop=0) -> outctx_base_t


    Create a new output context. To delete it, just use "delete pctx"
    
    @param ea (C++: ea_t)
    @param F (C++: flags_t)
    @param suspop (C++: int)
    """
    return _ida_ua.create_outctx(*args)

def print_insn_mnem(*args):
    r"""
    print_insn_mnem(ea) -> str


    Print instruction mnemonics.
    
    @param ea: linear address of the instruction (C++: ea_t)
    @return: success
    """
    return _ida_ua.print_insn_mnem(*args)
FCBF_CONT = _ida_ua.FCBF_CONT
"""
don't stop on decoding, or any other kind of error
"""

FCBF_ERR_REPL = _ida_ua.FCBF_ERR_REPL
"""
of a hex representation of the problematic byte

in case of an error, use a CP_REPLCHAR instead
"""

FCBF_FF_LIT = _ida_ua.FCBF_FF_LIT
"""
in case of codepoints == 0xFF, use it as-is (i.e., LATIN SMALL LETTER
Y WITH DIAERESIS) If both this, and FCBF_REPL are specified, this will
take precedence
"""

FCBF_DELIM = _ida_ua.FCBF_DELIM
"""
add the 'ash'-specified delimiters around the generated data. Note: if
those are not defined and the INFFL_ALLASM is not set,
'format_charlit()' will return an error
"""


def get_dtype_flag(*args):
    r"""
    get_dtype_flag(dtype) -> flags_t


    Get flags for 'op_t::dtype' field.
    
    
    @param dtype (C++: op_dtype_t)
    """
    return _ida_ua.get_dtype_flag(*args)

def get_dtype_size(*args):
    r"""
    get_dtype_size(dtype) -> size_t


    Get size of opt_::dtype field.
    
    
    @param dtype (C++: op_dtype_t)
    """
    return _ida_ua.get_dtype_size(*args)

def is_floating_dtype(*args):
    r"""
    is_floating_dtype(dtype) -> bool


    Is a floating type operand?
    
    
    @param dtype (C++: op_dtype_t)
    """
    return _ida_ua.is_floating_dtype(*args)

def create_insn(*args):
    r"""
    create_insn(ea, out=None) -> int


    Create an instruction at the specified address. This function checks
    if an instruction is present at the specified address and will try to
    create one if there is none. It will fail if there is a data item or
    other items hindering the creation of the new instruction. This
    function will also fill the 'out' structure.
    
    @param ea: linear address (C++: ea_t)
    @param out: the resulting instruction (C++: insn_t  *)
    @return: the length of the instruction or 0
    """
    return _ida_ua.create_insn(*args)

def decode_insn(*args):
    r"""
    decode_insn(out, ea) -> int


    Analyze the specified address and fill 'out'. This function does not
    modify the database. It just tries to interpret the specified address
    as an instruction and fills the 'out' structure.
    
    @param out: the resulting instruction (C++: insn_t  *)
    @param ea: linear address (C++: ea_t)
    @return: the length of the (possible) instruction or 0
    """
    return _ida_ua.decode_insn(*args)

def can_decode(*args):
    r"""
    can_decode(ea) -> bool


    Can the bytes at address 'ea' be decoded as instruction?
    
    @param ea: linear address (C++: ea_t)
    @return: whether or not the contents at that address could be a valid
             instruction
    """
    return _ida_ua.can_decode(*args)

def print_operand(*args):
    r"""
    print_operand(ea, n, getn_flags=0, newtype=None) -> str


    Generate text representation for operand #n. This function will
    generate the text representation of the specified operand (includes
    color codes.)
    
    @param ea: the item address (instruction or data) (C++: ea_t)
    @param n: operand number (0,1,2...). meaningful only for instructions
              (C++: int)
    @param getn_flags (C++: int)
    @param newtype: if specified, print the operand using the specified
                    type (C++: struct  printop_t  *)
    @return: success
    """
    return _ida_ua.print_operand(*args)

def decode_prev_insn(*args):
    r"""
    decode_prev_insn(out, ea) -> ea_t


    Decode previous instruction if it exists, fill 'out'.
    
    @param out: the resulting instruction (C++: insn_t  *)
    @param ea: the address to decode the previous instruction from (C++:
               ea_t)
    @return: the previous instruction address ( BADADDR -no such insn)
    """
    return _ida_ua.decode_prev_insn(*args)

def guess_table_address(*args):
    r"""
    guess_table_address(insn) -> ea_t


    Guess the jump table address (ibm pc specific)
    
    
    @param insn (C++: const  insn_t  &)
    """
    return _ida_ua.guess_table_address(*args)

def guess_table_size(*args):
    r"""
    guess_table_size(insn, jump_table) -> asize_t


    Guess the jump table size.
    
    
    @param insn (C++: const  insn_t  &)
    @param jump_table (C++: ea_t)
    """
    return _ida_ua.guess_table_size(*args)

def decode_preceding_insn(*args):
    r"""
    decode_preceding_insn(out, ea) -> PyObject *


    Decodes the preceding instruction. Please check ua.hpp / decode_preceding_insn()
    @param ea: current ea
    @param out: instruction storage
    @return: tuple(preceeding_ea or BADADDR, farref = Boolean)
    """
    return _ida_ua.decode_preceding_insn(*args)

def construct_macro(*args):
    r"""
    construct_macro(insn, enable, build_macro) -> bool


    See ua.hpp's construct_macro().
    """
    return _ida_ua.construct_macro(*args)

def get_dtype_by_size(*args):
    r"""
    get_dtype_by_size(size) -> int


    Get 'op_t::dtype' from size.
    
    
    @param size (C++: asize_t)
    """
    return _ida_ua.get_dtype_by_size(*args)

def get_immvals(*args):
    r"""
    get_immvals(ea, n, F=0) -> PyObject *


    Get immediate values at the specified address. This function decodes
    instruction at the specified address or inspects the data item. It
    finds immediate values and copies them to 'out'. This function will
    store the original value of the operands in 'out', unless the last
    bits of 'F' are "...0 11111111", in which case the transformed values
    (as needed for printing) will be stored instead.
    
    @param ea: address to analyze (C++: ea_t)
    @param n: number of operand (0.. UA_MAXOP -1), -1 means all operands
              (C++: int)
    @param F: flags for the specified address (C++: flags_t)
    @return: number of immediate values (0..2* UA_MAXOP )
    """
    return _ida_ua.get_immvals(*args)

def get_printable_immvals(*args):
    r"""
    get_printable_immvals(ea, n, F=0) -> PyObject *


    Get immediate ready-to-print values at the specified address
    
    @param ea: address to analyze (C++: ea_t)
    @param n: number of operand (0.. UA_MAXOP -1), -1 means all operands
              (C++: int)
    @param F: flags for the specified address (C++: flags_t)
    @return: number of immediate values (0..2* UA_MAXOP )
    """
    return _ida_ua.get_printable_immvals(*args)

def insn_t__from_ptrval__(*args):
    r"""
    insn_t__from_ptrval__(ptrval) -> insn_t
    """
    return _ida_ua.insn_t__from_ptrval__(*args)

def op_t__from_ptrval__(*args):
    r"""
    op_t__from_ptrval__(ptrval) -> op_t
    """
    return _ida_ua.op_t__from_ptrval__(*args)

def outctx_base_t__from_ptrval__(*args):
    r"""
    outctx_base_t__from_ptrval__(ptrval) -> outctx_base_t
    """
    return _ida_ua.outctx_base_t__from_ptrval__(*args)

def outctx_t__from_ptrval__(*args):
    r"""
    outctx_t__from_ptrval__(ptrval) -> outctx_t
    """
    return _ida_ua.outctx_t__from_ptrval__(*args)

#<pycode(py_ua)>
ua_mnem = print_insn_mnem
#</pycode(py_ua)>


if _BC695:
    import ida_idaapi
    def codeSeg(ea, opnum):
        insn = insn_t()
        if decode_insn(insn, ea):
            return _ida_ua.map_code_ea(insn, insn.ops[opnum])
        else:
            return ida_idaapi.BADADDR
    get_dtyp_by_size=get_dtype_by_size
    get_dtyp_flag=get_dtype_flag
    get_dtyp_size=get_dtype_size
    get_operand_immvals=get_immvals
    op_t.dtyp = op_t.dtype
    cmd = insn_t()
    @bc695redef
    def decode_insn(*args):
        if len(args) == 1:
            tmp = insn_t()
            rc = _ida_ua.decode_insn(tmp, args[0])
            cmd.assign(tmp)
            return rc
        else:
            return _ida_ua.decode_insn(*args)
    @bc695redef
    def create_insn(*args):
        if len(args) == 1:
            tmp = insn_t()
            rc = _ida_ua.create_insn(args[0], tmp)
            cmd.assign(tmp)
            return rc
        else:
            return _ida_ua.create_insn(*args)
    @bc695redef
    def decode_prev_insn(*args):
        if len(args) == 1:
            tmp = insn_t()
            rc = _ida_ua.decode_prev_insn(tmp, args[0])
            cmd.assign(tmp)
            return rc
        else:
            return _ida_ua.decode_prev_insn(*args)
    @bc695redef
    def decode_preceding_insn(*args):
        if len(args) == 1:
            tmp = insn_t()
            rc = _ida_ua.decode_preceding_insn(tmp, args[0])
            cmd.assign(tmp)
            return rc
        else:
            return _ida_ua.decode_preceding_insn(*args)
    import ida_ida
    UA_MAXOP=ida_ida.UA_MAXOP
    dt_3byte=dt_byte
    tbo_123=0
    tbo_132=0
    tbo_213=0
    tbo_231=0
    tbo_312=0
    tbo_321=0
    def ua_add_cref(opoff, to, rtype):
        return cmd.add_cref(to, opoff, rtype)
    def ua_add_dref(opoff, to, rtype):
        return cmd.add_dref(to, opoff, rtype)
    def ua_add_off_drefs(x, rtype):
        return cmd.add_off_drefs(x, rtype, 0)
    def ua_add_off_drefs2(x, rtype, outf):
        return cmd.add_off_drefs(x, rtype, outf)
    def ua_dodata(ea, dtype):
        return cmd.create_op_data(ea, 0, dtype)
    def ua_dodata2(opoff, ea, dtype):
        return cmd.create_op_data(ea, opoff, dtype)
    def ua_stkvar2(x, v, flags):
        return cmd.create_stkvar(x, v, flags)



